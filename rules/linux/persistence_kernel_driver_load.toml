[metadata]
creation_date = "2023/10/26"
integration = ["auditd_manager"]
maturity = "production"
updated_date = "2025/01/08"

[rule]
author = ["Elastic"]
description = """
Detects the loading of a Linux kernel module through system calls. Threat actors may leverage Linux kernel modules to
load a rootkit on a system providing them with complete control and the ability to hide from security products. As other
rules monitor for the addition of Linux kernel modules through system utilities or .ko files, this rule covers the gap
that evasive rootkits leverage by monitoring for kernel module additions on the lowest level through auditd_manager.
"""
from = "now-9m"
index = ["auditbeat-*", "logs-auditd_manager.auditd-*"]
language = "eql"
license = "Elastic License v2"
name = "Kernel Driver Load"
risk_score = 21
rule_id = "3e12a439-d002-4944-bc42-171c0dcb9b96"
setup = """## Setup
This rule requires the use of the `auditd_manager` integration. `Auditd_manager` is a tool designed to simplify and enhance the management of the audit subsystem in Linux systems. It provides a user-friendly interface and automation capabilities for configuring and monitoring system auditing through the auditd daemon. With `auditd_manager`, administrators can easily define audit rules, track system events, and generate comprehensive audit reports, improving overall security and compliance in the system. The following steps should be executed in order to install and deploy `auditd_manager` on a Linux system. 

```
Kibana -->
Management -->
Integrations -->
Auditd Manager -->
Add Auditd Manager
```

`Auditd_manager` subscribes to the kernel and receives events as they occur without any additional configuration. However, if more advanced configuration is required to detect specific behavior, audit rules can be added to the integration in either the "audit rules" configuration box or the "auditd rule files" box by specifying a file to read the audit rules from. 

For this detection rule to trigger, the following additional audit rules are required to be added to the integration:
```
-a always,exit -F arch=b64 -S finit_module -S init_module -S delete_module -F auid!=-1 -k modules
-a always,exit -F arch=b32 -S finit_module -S init_module -S delete_module -F auid!=-1 -k modules
```

Add the newly installed `auditd manager` to an agent policy, and deploy the agent on a Linux system from which auditd log files are desirable.
"""
severity = "low"
tags = [
    "Data Source: Auditd Manager",
    "Domain: Endpoint",
    "OS: Linux",
    "Use Case: Threat Detection",
    "Tactic: Persistence",
    "Tactic: Defense Evasion",
]
timestamp_override = "event.ingested"
type = "eql"

query = '''
driver where host.os.type == "linux" and event.action == "loaded-kernel-module" and
auditd.data.syscall in ("init_module", "finit_module")
'''
note = """## Triage and analysis

### Disclaimer

This investigation guide was generated using generative AI technology and has been reviewed to improve its accuracy and relevance. While every effort has been made to ensure its quality, we recommend validating the content and adapting it to suit your specific environment and operational needs.

### Investigating Kernel Driver Load

Kernel modules extend the functionality of the Linux kernel, allowing dynamic loading of drivers and other components. Adversaries exploit this by loading malicious modules, or rootkits, to gain stealthy control over systems. The detection rule monitors system calls related to module loading, identifying suspicious activity by tracking specific actions indicative of unauthorized kernel modifications.

### Possible investigation steps

- Review the alert details to confirm the event action is "loaded-kernel-module" and verify the syscall involved is either "init_module" or "finit_module" as these are indicative of module loading.
- Identify the specific kernel module that was loaded by examining the associated metadata in the alert, such as the module name or path, if available.
- Check the timestamp of the event to determine when the module was loaded and correlate this with other system activities or logs around the same time for additional context.
- Investigate the user or process that initiated the module load by examining the user ID and process ID fields in the alert to determine if it aligns with expected behavior or known legitimate processes.
- Use Osquery to list all currently loaded kernel modules and their details to identify any unfamiliar or suspicious modules. Example query: `SELECT name, size, refcount, srcversion FROM kernel_modules;`
- Cross-reference the loaded module with known good or bad modules by consulting threat intelligence sources or internal documentation to assess its legitimacy.
- Analyze system logs, such as syslog or dmesg, for any additional messages or errors related to the module load event that could provide further insights.
- Investigate the system's audit logs for any preceding or subsequent suspicious activities that might be related to the module load, such as unauthorized access attempts or privilege escalation.
- Check for any recent changes to the system's configuration or installed software that could explain the module load, ensuring these changes are authorized and documented.
- If the module is determined to be suspicious, consider conducting a deeper forensic analysis of the system to uncover any potential rootkits or other malicious activities that may have been facilitated by the module load.

### False positive analysis

- Legitimate software updates or installations may trigger the loading of kernel modules, leading to false positives. Users can manage this by creating exceptions for known and trusted software update processes.
- Certain hardware drivers, such as those for graphics cards or network adapters, may load kernel modules during normal operation. To handle these, users can whitelist specific drivers or hardware-related processes that are known to be safe.
- System administrators performing routine maintenance or configuration changes might load kernel modules, which could be flagged as suspicious. Users should document and exclude these activities from monitoring when performed by authorized personnel.
- Security software or monitoring tools that interact with the kernel might also load modules as part of their normal function. Users can create exceptions for these tools by verifying their legitimacy and adding them to an exclusion list.
- Custom or in-house developed applications that require kernel module loading for functionality might be misidentified as threats. Users should ensure these applications are properly documented and excluded from detection rules if they are verified as safe.

### Response and remediation

- Immediately isolate the affected system from the network to prevent further malicious activity and lateral movement.
- Use forensic tools to capture a memory dump and disk image of the affected system for further analysis.
- Investigate the loaded kernel module by checking its origin, signature, and any associated files or processes to determine if it is malicious.
- Cross-reference the module's details with known threat intelligence databases to identify any known rootkits or malicious actors.
- If a rootkit is confirmed, remove the malicious module using safe methods such as rebooting into a clean environment and using trusted tools to unload the module.
- Restore the system from a known good backup if the integrity of the system cannot be assured after module removal.
- Escalate the incident to the security operations center (SOC) or incident response team for further investigation and to determine if other systems are affected.
- Implement enhanced logging policies to monitor for future unauthorized kernel module loads, including detailed audit logs of system calls and module activities.
- Integrate with security information and event management (SIEM) systems to correlate module loading events with other suspicious activities across the network.
- Apply system hardening measures such as disabling unnecessary kernel module loading, enforcing strict access controls, and regularly updating the system to patch vulnerabilities."""


[[rule.threat]]
framework = "MITRE ATT&CK"
[[rule.threat.technique]]
id = "T1547"
name = "Boot or Logon Autostart Execution"
reference = "https://attack.mitre.org/techniques/T1547/"
[[rule.threat.technique.subtechnique]]
id = "T1547.006"
name = "Kernel Modules and Extensions"
reference = "https://attack.mitre.org/techniques/T1547/006/"



[rule.threat.tactic]
id = "TA0003"
name = "Persistence"
reference = "https://attack.mitre.org/tactics/TA0003/"
[[rule.threat]]
framework = "MITRE ATT&CK"
[[rule.threat.technique]]
id = "T1014"
name = "Rootkit"
reference = "https://attack.mitre.org/techniques/T1014/"


[rule.threat.tactic]
id = "TA0005"
name = "Defense Evasion"
reference = "https://attack.mitre.org/tactics/TA0005/"

