[hunt]
author = "Elastic"
description = """
This hunt identifies segmentation faults (segfaults) and potential buffer overflow attacks on Linux systems by parsing syslog messages related to segfaults. It captures details about the crashing process, shared object file, and other relevant information to help identify and investigate potential exploitation attempts.
"""
integration = ["system"]
uuid = "j3a3d0g0-0123-4j3j-a74j-be789ab80h12"
name = "Segmentation Fault & Potential Buffer Overflow Hunting"
language = "ES|QL"
license = "Elastic License v2"
notes = [
    "Detects segfaults and parses syslog messages related to segfaults to identify the crashing process and shared object file along with additional crash details.",
    "Uses GROK to extract relevant fields from syslog messages.",
    "Counts occurrences of segfaults within a plain text message field to potentially detect buffer overflow attacks and unsuccessful process injection attempts.",
    "Removes prepending spaces from syslog messages using EVAL to ensure consistent parsing.",
    "Depending on the Syslog configuration, additional parsing may be required to extract the necessary fields from the message."
]
mitre = ["T1203", "T1068"]

query = [
'''
from logs-system.syslog*
| where @timestamp > now() - 12 hour
| where host.os.type == "linux" and process.name == "kernel" and message like "*segfault*"
| grok message "\\[%{NUMBER:timestamp}\\] %{WORD:process}\\[%{NUMBER:pid}\\]: segfault at %{BASE16NUM:segfault_address} ip %{BASE16NUM:instruction_pointer} sp %{BASE16NUM:stack_pointer} error %{NUMBER:error_code} in %{DATA:so_file}\\[%{BASE16NUM:so_base_address}\\+%{BASE16NUM:so_offset}\\]"
| keep timestamp, process, pid, so_file, segfault_address, instruction_pointer, stack_pointer, error_code, so_base_address, so_offset
''',
'''
from logs-system.syslog*
| where host.os.type == "linux" and process.name == "kernel" and message like "*segfault*"
| where @timestamp > now() - 12 hour
| grok message "\\[%{DATA:timestamp}\\] %{WORD:process}\\[%{NUMBER:pid}\\]: segfault at %{BASE16NUM:segfault_address} ip %{BASE16NUM:instruction_pointer} sp %{BASE16NUM:stack_pointer} error %{NUMBER:error_code} in %{DATA:so_name}\\[%{BASE16NUM:so_base_address}\\+%{BASE16NUM:so_offset}\\] likely on CPU %{NUMBER:cpu} \\(core %{NUMBER:core}, socket %{NUMBER:socket}\\)"
| eval timestamp = REPLACE(timestamp, "\\s+", "")
| keep timestamp, process, pid, segfault_address, instruction_pointer, stack_pointer, error_code, so_name, so_base_address, so_offset, cpu, core, socket
| stats process_count = count(process), so_count = count(so_name) by process, so_name
// Alter this threshold to make sense for your environment
| where process_count > 100
| limit 10
'''
]
